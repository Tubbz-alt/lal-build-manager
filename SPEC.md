# lal spec
`lal` is a simple command line tool that works on folders with a valid `manifest.json`, and accepts the following commands:

- [`lal fetch`](#lal-fetch) - fetch dependencies from `manifest.json` into `INPUT`
- [`lal update`](#lal-update-components) - update arbitrary dependencies into `INPUT`
- [`lal status`](#lal-status) - print current INPUT dependencies with origin
- [`lal verify`](#lal-verify) - verify manifest validity + verify flat lockfile dependency tree
- [`lal env`](#lal-env-environment) - control build environment
- [`lal build [name]`](#lal-build-name-flags) - run canonical build in docker with current directory mounted
- [`lal shell`](#lal-shell) - enter container environment mounting current directory
- [`lal script`](#lal-script-name) - runs a non-build script through lal shell
- [`lal configure`](#lal-configure) - generate configuration file
- [`lal init`](#lal-init) - generate manifest file
- [`lal stash`](#lal-stash-name) - copies current `OUTPUT` to cache
- [`lal upgrade`](#lal-upgrade) - performs an upgrade check
- [`lal clean`](#lal-clean) - cleans up cache directory
- [`lal export`](#lal-export-component) - obtain a raw tarball from artifactory
- [`lal query`](#lal-query-component) - list versions of a component on artifactory
- [`lal remove`](#lal-remove-components) - remove components from `INPUT` and `manifest.json`
- [`lal publish`](#lal-publish) - publish release builds to artifactory

## Manifest
A per-repo file. Format looks like this (here annotated with illegal comments):

```json
{
  "name": "libwebsockets",  // name of repo
  "environment": "centos",  // name of environment found in the lal config
  "components": {           // map of components and default configuration
    "libwebsockets": {
      "defaultConfig": "release",
      "configurations": ["release", "clang"]
    },
    "websockets_tests": {
      "defaultConfig": "coverage",
      "configurations": ["coverage", "release", "clang"]
    }
  },
  "dependencies": {
    "ciscossl": 42
  },
  "devDependencies": {
    "gtest": 42
  }
}
```

## Lockfile
A per-build file auto-generated by `lal build` and will reduce the lockfiles generated from dependencies to provide aggregated information.

```json
{
  "name": "edonus",
  "config": "release",
  "container": {
    "name": "edonusdevelopers/centos_build",
    "tag": "2016-04-03"
  },
  "environment": "centos",
  "tool": "0.10.0", // from `lal --version`
  "version": "5",  // from --with-version or "EXPERIMENTAL-{randomhex}"
  "dependencies": {
    "libwebsockets": {
      "name": "libwebsockets",
      "config": "release",
      "container": {
        "name": "edonusdevelopers/centos_build",
        "tag": "2016-04-03"
      },
      "environment": "centos",
      "version": "47",
      "tool": "0.10.0",
      "dependencies": {
        "ciscossl": {
          "name": "ciscossl",
          "config": "release",
          "container": {
            "name": "edonusdevelopers/centos_build",
            "tag": "2016-04-03"
          },
          "environment": "centos",
          "version": "200",
          "tool": "0.10.0",
          "dependencies": {}
        }
      }
    },
    "ciscossl": {
      "name": "ciscossl",
      "config": "release",
      "container": {
        "name": "edonusdevelopers/centos_build",
        "tag": "2016-04-03"
      },
      "environment": "centos",
      "version": "200",
      "tool": "0.10.0",
      "dependencies": {}
    }
  }
}
```

This struct is fully recursive in the sense that every value in the dependencies hash is also a valid lockfile.

## Config
A per-machine configuration file in `~/.lal/config` generated by `lal configure`.

```json
{
  "artifactory": {
    "server": "https://engci-maven-master.cisco.com/artifactory",
    "group": "CME-release",
    "vgroup": "https://engci-maven.cisco.com/artifactory/CME-group"
  },
  "cache": "/home/devuser/.lal/cache",
  "environments": {
    "centos": { "container": "edonusdevelopers/centos_build", "tag": "latest" },
    "xenial": { "container": "edonusdevelopers/build_xenial", "tag": "latest" },
    "transcoder": { "container": "edonusdevelopers/mygdon-transcoder", "tag": "latest" }
  },
  "upgradeCheck": "2016-06-30T12:20:10.126707483+00:00",
  "mounts": [
    {
      "src": "/mnt/tools",
      "dest": "/tools",
      "readonly": true
    }
  ]
}
```

Every repository is required to specify the name of one of the specified environments in their `manifest.json`.

The `upgradeCheck` value is updated automatically by `lal upgrade`.

## .lalopts
A per-repo temporary file primarily for `lal env` that overrides the current environment.

```json
{
  "env": "xenial"
}
```

When this file exists, every `lal` command will use this environment rather than the default one. It is created by [`lal-env`](#lal-env-environment).

This file is intended to be gitignored because it overrides `manifest.environment`.

## Caching
The local cache is populated by fetches from the registry, or calls to `stash` them.

```sh
~/.lal/cache $ tree .
├── environments
│   ├── centos
│   │   └── ciscossl
│   │       └── 6
│   │           └── ciscossl.tar
│   └── xenial
│       └── ciscossl
│           └── 6
│               └── ciscossl.tar
├── globals
│   └── ciscossl
│       └── 6
│           └── ciscossl.tar
└── stash
    └── ciscossl
        └── asan
            └── ciscossl.tar
```

Sources:

- `globals` are default components unpacked straight from the registry
- `environments` are components from the registry under a specific environment namespace
- `stash` are tarballs of OUTPUT of builds when doing `lal stash <name>`

Note that the globals will contain duplicated components from one or more of the environments subfolders.

## Versioning
As implied by the structure of the Manifest, Lockfile, and cache directories, the *only* versioning scheme supported by `lal` is a monotonically increasing integer sequence.

### Subcommands
#### lal status
Provides list of dependencies currently in `INPUT`.
If they are not in the manifest they will be listed as _extraneous_.
If they are modified (not a global fetch) they will be listed as _modified_.

Extra flags:

- `--full` or `-f`: show the full dependency tree

Alias: `lal ls`

#### lal env [environment]
Subcommand that controls the current environment. This is a sticky, repo-wide setting stored in `$PWD/.lalopts` when working with non-standard environments.


```sh
$ lal env
default
# every lal command will defer to `manifest.json` for environment settings

$ lal env set xenial # writes { "environment": "xenial" } to .lalopts
$ lal env update # invokes docker pull of the xenial image
# now every lal command will warn if `manifest.environment != lal env`
$ lal fetch # fetches from xenial
$ lal build # build using xenial components
$ lal shell # enters xenial shell
$ lal run unit-test websocket_server_test 5 asan # runs unit test in xenial shell

$ lal env reset # deletes .lalopts if it exists

# lal now behaves as usual, doing all commands in the described environment in manifest.json
```

This is an advanced command for people developing on temporary, non-standard environments.
If you would like to override the environment on a command-by-command basis, there is an [option](#universal-options) for that as well.

#### lal build [name] [flags]
Runs the `BUILD` script in the current directory in the container.

If no arguments are suppplied it will run `./BUILD $name $config` where `name` is the value of `name` in the manifest, and `config` is the name of the component's `defaultConfig`.

E.g. `lal build` in media-engine will `./BUILD media-engine release` in the container.

`lal build` will run `lal verify` and abort if this fails. This warning can be overridden with `-f` or `--force`. There are legit developer reasons to ignore the `lal verify` reason when building with custom dependencies, but once code gets published, it must build without these warnings.

Release specific flags:

- *--release*: Generate a tarball and lockfile in `./ARTIFACT` folder after building
- *--with-version n*: Jenkins specific option which will specify lockfile version

-If `--with-version` is passed, `lal verify` must pass for build to pass (regardless of `-f`).

Passing configuration flags:

- *--config=name*: Passes a named config to `BUILD` as `$2`.

This allows multiple blessed configurations of the same component, i.e. `lal build dme-unit-tests --config=asan` and `lal build dme-unit-tests --config=debug`. Both are valid provided `dme-unit-tests` provides those `configurations` in the `components` part of the manifest.

#### lal update [components..]

 - *lal update component [--save]*: fetches the latest version of a component. The optional `--save` flag will also update the manifest file locally.

 - *lal update component=version [--save]*: fetches a specific version. If the version is parsable as an integer, it is fetched from artifactory. Otherwise, it is assumed to be a stashed version.

Many `component` or `component=version` arguments can be used in one invocation.

#### lal fetch
 - *lal fetch [--core]*: fetches all versions corresponding to the manifest from the registry and puts them into `INPUT`. The optional `--core` flag will disregard any `devDependencies`.

#### lal shell
Enters an interactive shell in the container corresponding to the environment key in the manifest mounting the current directory.

Useful for experimental builds using internal scripts in a repo.
Assumes you have run `lal fetch` or equivalent so that `INPUT` is ready for this.

lal shell should simply run:

```sh
docker run \
  -v $HOME/.gitconfig:/home/lal/.gitconfig \
  -v $PWD:/home/lal/volume \
  -w /home/lal/volume \
  --net host \
  --user lal \
  -it ${SOME_CONTAINER} \
  /bin/bash
```

Note that the config can be edited to pass in extra mounts.

lal shell should allow passing in trailing arguments to run arbitrary commands:

- `lal shell ./BUILD something` # runs this command rather than `/bin/bash` and removes `-i`
- `lal shell -p ./BUILD something` # same, but adds --privileged to `docker`
- `lal shell bash -c "cmd1; cmd2"` # multiple commands in one go
- `lal shell --print-only` prints above command
- `lal shell --print-only ./BUILD something` # prints what would have been done

Alias: `lal sh`

#### lal script [name]
Runs scripts in the local `.lal/scripts/` folder via `lal shell`. Because `lal shell` mounts `$PWD`, the scripts folder can contain parametrised scripts such as:

```sh
#!/bin/bash
# contents of .lal/scripts/subroutine
main() {
  echo "hi $1 $2"
}

completer() {
  echo "foo bar"
}
```

Which could be invoked with `lal script subroutine there mr`, which would `echo hi there mr` in the container. An optional `completer` function can be supplied for autocomplete of values.

Alias: `lal run`

#### lal stash [name]
Stashes the current `OUTPUT` folder to in `~/.lal/cache/stash/${component}/${NAME}` for future reuse. This can be put into another repository with `lal update component=name`

Alias: `lal save`

#### lal verify
Helper command used by `lal build` exposed for convenience/sanity. Verifies that:

- `manifest.json` exists in `$PWD` and is valid JSON
- dependencies in `INPUT` match `manifest.json`
- the dependency tree is flat
- dependencies in `INPUT` contains only global dependencies
- dependencies in `INPUT` were built using the correct environment

`lal build` normally guards on this command.

#### lal configure
Sets up a default config with a pre-configured defaults of:

- docker container set to use
- artifactory server (default: `https://engci-maven-master.cisco.com/artifactory`)
- artifactory group (default: `CME-release`)
- cache directory to use (default: `~/.lal/cache`)

To use different settings, edit `~/.lal/config` and manage it yourself. Note that we occasionally break the format of this file.

#### lal init [environment]
Creates a basic `manifest.json` in the current directory, assuming directory name as the name of the main component.

A `-f` flag can be supplied to force overwrite the manifest.

```sh
lal init -f centos
```

#### lal upgrade
Performs an upgrade check of `lal`. If new versions are found, it reports how to upgrade your lal tool. This is normally checked daily. But it can be done manually with this command.

#### lal clean
Deletes artifacts in the cache directory older than 14 days. The day is configurable with `-d <days>`.

#### lal export [component]
Exports a build artifact from artifactory for a component into `$PWD` or directory of choice. The component can be either the name of the component for latest version, or suffixed with `=version` for a specific version:

```sh
lal export gtest -o mystorage/
test -f mystorage/gtest.tar.gz

lal --env xenial export liblzma=6
test -f ./liblzma.tar.gz
```

NB: export does not read the manifest.json for environment overrides.

#### lal query [component]
Lists the availble version on artifactory for a given component in the current environment.

```sh
lal query libwebsockets
```

NB: query does not read the manifest.json for environment overrides.

#### lal remove [components..]
Removes and optionally saves a removal of a component from `INPUT` and the manifest.

```sh
lal remove libwebsockets --save
lal remove gtest --save-dev
```

Note you can only use one of save or save-dev at a time. Without either save flag, this subcommand simply deletes the corresponding subdirectory of `INPUT`.

Alias: `lal rm`

#### lal publish
Publishes a release build in the local `ARTIFACT` subdirectory provided it is built with a correct version and proper credentials are presented.

```sh
lal env set xenial
lal fetch
lal build libldns --release --with-version=20
lal publish libldns
```

The publish command will verify that `./ARTIFACT/lockfile.json` is built in xenial and that the version is not experimental.

The uploaded artifact will in this case end up in `https://artifactory.host/artifactory/CME-group/libldns/20/xenial/`. Note that if the artifact already exists, this will fail unless `--force` is passed to `lal publish`.

### Universal Options

- `--help` or `-h`
- `-v`
- `--env` or `-e`

Note that `-v` is a global option that gradually increases verbosity (allows multiple uses), and goes before subcommands.

```sh
lal update zlib # update with only standard logging (info!, warn!, and error!)
lal -v fetch # fetch with debug! messages
lal -vv build # build with debug! and trace! messages
```

The `--env` flag will override the default environment in both `manifest.environment` and `.lalopts` for the current command:

```sh
lal --env xenial fetch
lal -e xenial verify
lal -e xenial build
lal -e xenial shell
lal -e xenial script unit-test websocket_server_test 5 asan
```

Because these commands are often used together you can instead make it sticky with [`lal env`](#lal-env-environment).

For full autogenerated help of all flags of every subcommand help can be requested:

```sh
lal build -h
lal help build # equivalent
```
