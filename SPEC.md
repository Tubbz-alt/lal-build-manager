# lal spec
`lal` is a simple command line tool that works on folders with a valid `manifest.json`, and accepts the following commands:

- [`lal fetch`](#lal-fetch) - fetch dependencies from `manifest.json` into `INPUT`
- [`lal update`](#lal-update-components) - update arbitrary dependencies into `INPUT`
- [`lal status`](#lal-status) - print current INPUT dependencies with origin
- [`lal verify`](#lal-verify) - verify manifest validity + verify flat lockfile dependency tree
- [`lal build [name]`](#lal-build-name-flags) - run canonical build in docker with current directory mounted
- [`lal shell`](#lal-shell) - enter container environment mounting current directory
- [`lal configure`](#lal-configure) - generate configuration file
- [`lal init`](#lal-init) - generate manifest file
- [`lal stash name`](#lal-stash-name) - copies current `OUTPUT` to cache
- [`lal update-manifest`](#lal-update-manifest) - updates manifest to match `INPUT`
- [`lal multibuild`](#lal-multibuild-components) - automate `stash` and `get` to allow simultaneous rebuilds
- [`lal upgrade`](#lal-upgrade) - performs an upgrade check
- [`lal clean`](#lal-clean) - cleans up cache directory

## Manifest
A per-repo file. Format looks like this (here annotated with illegal comments):

```json
{
  "name": "libwebsockets",  // name of repo
  "components": {           // map of components and default configuration
    "libwebsockets": {
      "defaultConfig": "release",
      "configurations": ["release", "clang"]
    },
    "websockets_tests": {
      "defaultConfig": "coverage",
      "configurations": ["coverage", "release", "clang"]
    }
  },
  "dependencies": {
    "ciscossl": 42
  },
  "devDependencies": {
    "gtest": 42
  }
}
```

## Lockfile
A per-build file auto-generated by `lal build` and will reduce the lockfiles generated from dependencies to provide aggregated information.

```json
{
  "name": "edonus",
  "config": "release",
  "container": {
    "name": "edonusdevelopers/centos_build",
    "tag": "2016-04-03"
  },
  "tool": "0.10.0", // from `lal --version`
  "version": "5",  // from --with-version or "EXPERIMENTAL"
  "dependencies": {
    "libwebsockets": {
      "name": "libwebsockets",
      "config": "release",
      "container": {
        "name": "edonusdevelopers/centos_build",
        "tag": "2016-04-03"
      },
      "version": "47",
      "tool": "0.10.0",
      "dependencies": {
        "ciscossl": {
          "name": "ciscossl",
          "config": "release",
          "container": {
            "name": "edonusdevelopers/centos_build",
            "tag": "2016-04-03"
          },
          "version": "200",
          "tool": "0.10.0",
          "dependencies": {}
        }
      }
    },
    "ciscossl": {
      "name": "ciscossl",
      "config": "release",
      "container": {
        "name": "edonusdevelopers/centos_build",
        "tag": "2016-04-03"
      },
      "version": "200",
      "tool": "0.10.0",
      "dependencies": {}
    }
  }
}
```

This struct is fully recursive in the sense that every value in the dependencies hash is also a valid lockfile.

## .lalrc
A per-machine configuration file from `lal configure`.

```json
{
  "container": "edonusdevelopers/centos_build",
  "cache": "~/.lal/cache",
  "registry": "http://engci-maven.cisco.com/artifactory/CME-group"
}
```

A specialized per-repo configuration file (`$PWD/.lalrc`) with the same format can override specific keys from the machine configuration.

## Caching
The local cache is populated when doing fetches from the registry, when building locally, stashing them, or when linking them directly.

```sh
~/.lal/cache $ tree .
.
├── globals
│   └── ciscossl
│       └── 6
│           ├── ciscossl.tar.gz
│           └── lockfile.json
└── stash
    └── ciscossl
        └── asan
            ├── ciscossl.tar.gz
            └── lockfile.json
```

Sources:

- `globals` are unpacked straight from the registry
- `stash` are tarballs of OUTPUT of builds when doing `lal stash <name>`


### Common Command Specification
#### lal status
Provides list of dependencies currently in `INPUT`.
If they are not in the manifest they will be listed as _extraneous_.
If they are modified (not a global fetch) they will be listed as _modified_.

#### lal build [name] [flags]
Runs the `BUILD` script in the current directory in the container.

If no arguments are suppplied it will run `./BUILD $name` where `name` is the value of `name` in the manifest.

E.g. `lal build` in monolith will `./BUILD dme` in the container.

`lal build` will run `lal verify` and warn if this fails, but proceed anyway. The warning is a developer notice that the build will not be identical on jenkins due to local modifications and should not be ignored indefinitely.

Release specific flags:

- *--release*: Generate a tarball and lockfile in `./ARTIFACT` folder after building
- *--with-version n*: Jenkins specific option which will specify lockfile version

If `--with-version` is passed, `lal verify` must pass for build to pass.

Passing configuration flags:

- *--config=name*: Passes a named config to `BUILD` as `$2`.

This allows multiple blessed configurations of the same component, i.e. `lal build dme-unit-tests --config=asan` and `lal build dme-uni-tests --config=debug`. Both are valid provided `dme-unit-tests` provides those `configurations` in the `components` part of the manifest.

#### lal update [components..]

 - *lal update component [--save]*: fetches the latest version of a component. The optional `--save` flag will also update the manifest file locally.

 - *lal update component=version [--save]*: fetches a specific version. If the version is parsable as an integer, it is fetched from artifactory. Otherwise, it is assumed to be a stashed version.

Many `component` or `component=version` arguments can be used in one invocation.

#### lal fetch
 - *lal fetch [--core]*: fetches all versions corresponding to the manifest from the registry and puts them into `INPUT`. The optional `--core` flag will disregard any `devDependencies`.

### Uncommon/Advanced/Internal Command Specification
#### lal shell
Enters an interactive shell in the container listed in `.lalrc` mounting the current directory.

Useful for experimental builds with stuff like `bcm` and `opts`.
Assumes you have run `lal fetch` or equivalent so that `INPUT` is ready for this.

Should run:

```sh
docker run \
  -v $HOME/.gitconfig:/home/lal/.gitconfig \
  -v $PWD:/home/lal/volume \
  -w /home/lal/volume \
  --net host \
  --cap-add SYS_NICE \
  --user lal \
  -it $LALCONTAINER \
  /bin/bash
```

You may just have your own wrapper for this anyway, but this is the canonical one. You can not use `lal` inside the container anyway.

#### lal stash [name]
Stashes the current `OUTPUT` folder to in `~/.lal/cache/stash/${component}/${NAME}` for future reuse. This can be put into another repository with `lal update component=name`

#### lal multibuild [components]...
Allows for multiple builds of components in different repositories like `./build` did. This must be run above your github checkouts, i.e.:

```sh
~/repos $ tree -d -L 1
.
├── ciscossl
├── ciscossl-fom
├── expat
├── freetype
├── fribidi
├── gperftools
├── libarchive
├── libcurl
├── libldns
├── liblzma
├── libopus
├── libpng
├── libunbound
├── libwebsockets
├── libyaml
├── mari-adaptation-resilience
├── media-engine
├── p7zip
├── yajl
└── zlib

~/repos $ lal multibuild ciscossl dme
```

This would traverse the immediate subdirectories, inspect their manifest files, and find two components named `ciscossl` and `dme`, then figure out what order to build them in, and build them sequentially.

In this case, it would build `ciscossl` inside `ciscossl`, `stash` it, `update` it into `media-engine`, then `lal build dme` inside `media-engine`.

#### lal update-manifest
Updates the manifest according to what's actually in `./INPUT`. This will read the version information in each `INPUT` subdirectory, then if these are all global dependencies, it will update `manifest.json` with the updated versions.

#### lal verify
Verifies that:

- `manifest.json` exists in `$PWD` and is valid JSON
- dependencies in `INPUT` match `manifest.json`.
- the dependency tree is flat.
- `INPUT` contains only global dependencies.

#### lal configure
Interactively configures:

- docker container to use for `build` (default: edonusdevelopers/centos_build)
- registry to use (default: http://engci-maven.cisco.com/artifactory/CME-group)
- cache directory to use (default: ~/.lal/cache)
- cache size warning (default: 5G)

To get defaults use `lal configure -y`.

#### lal init
Creates a basic `manifest.json` in the current directory, assuming directory name as the name of the main component.

#### lal upgrade
Performs an upgrade check of `lal`. If new versions are found, it reports how to upgrade your lal tool. This is normally only done implicitly (daily). But can be done explicitly with this command.

#### lal clean
Deletes artifacts in the cache directory older than 14 days. The day is configurable with `-d <days>`.

### Universal Options

- `--help` or `-h`
