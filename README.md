# lal dependency manager
A simple and opinionated dependency manager for C++.

## Design
`lal` is a simple command line tool that works on folders with a valid `manifest.json`, and accepts the following commands:

- `lal install` - install dependencies from `manifest.json` into `INPUT`
- `lal status` - print current installed dependencies with origin
- `lal build [name]` - run canonical build in current directory
- `lal link` - make current `OUTPUT` available as a symlink
- `lal link dependency` - artificially substitute a dependency with a linked one
- `lal update-manifest`
- `lal verify` - verify manifest validity + verify flat lockfile dependency tree

## Manifest
Format looks like this (here annotated with illegal comments):

```json
{
  "name": "libwebsockets",  // name of repo
  "version": 10,            // corresponds to latest tag
  "components": ["$1"],     // list of components (used if more than one)
  "scripts": {              // canonical build + test scripts for repo
    "build": "./BUILD $1 $2",
    "test": "./BUILD $1-unit-tests $2"
  },
  "dependencies": {
    "ciscossl": 42
  },
  "devDependencies": {
    "gtest": 42
  }
}
```

## Lockfile
A per-build file auto-generated by `lal build` and will reduce the lockfiles generated from dependencies to provide aggregated information.

```json
{
  "name": "monolith",
  "date": "datestring",
  "commit": "sha",
  "container": {
    "name": "edonusdevelopers/centos_build",
    "version": "sha"
  },
  "versions": {
    "ciscossl": {
      "target": "ncp.amd64",
      "version": 6,
      "order": "global"
    },
    "libwebsockets": {
      "target": "ncp.amd64",
      "version": 5,
      "order": "global",
      "versions": {
        "ciscossl": {
          "target": "ncp.amd64",
          "version": 6,
          "order": "global"
        }
      }
    }
  },
  "dev": {
    "gtest": {
      "version": 42
    }
  }
}
```

## .lalrc
Per machine configuration file from `lal configure`.

```json
{ 
  "git-url": "git@sqbu-github.cisco.com:Edonus/",
  "target": "ncp.amd64",
  "container": "edonusdevelopers/centos_build",
  "cache": "~/.lal/cache",
  "registry": "https://artifactory.wherever"
}
```

## Installation
Uses [node](https://nodejs.org/en/download/package-manager/). We target the 4.x LTS and newer.

Then:

```sh
npm install -g https://sqbu-github.cisco.com/ealbrigt/lal/archive/master.tar.gz
lal configure
```

Subject to change.

## Updating
TODO: At some point `lal` will version check itself and let you know of a new version, and the command to update it. It can also give indications of docker container updates. This tool needs to use `npm shrinkwrap`.

## Caching
The local cache is populated when doing installs from the registry, when building locally and stashing them, or when linking them directly.

```sh
~/.lal/cache $ tree -aC  --dirsfirst .
.
├── globals
│   └── ncp.amd64
│       └── ciscossl
│           └── 6
│               ├── libcrypto.a
│               ├── libssl.a
│               └── lockfile.json
├── links
│   └── ncp.amd64
│       └── ciscossl -> /home/clux/repos/ciscossl/OUTPUT
└── stash
    └── ncp.amd64
        └── ciscossl
            └── asan
                ├── libcrypto.a
                ├── libssl.a
                └── lockfile.json
```

Sources:

- `globals` are unpacked straight from the registry
- `links` are created with `lal link`
- `stash` are copied from OUTPUT of builds when doing `lal stash name`


### Common Command Specification
#### lal status
Provides list of dependencies currently installed.
If they are not in the manifest they will be listed as _extraneous_.
If they are modified (not a global fetch) they will be listed as _modified_.

#### lal build [name]
Runs the `scripts.build` shell script in the manifest file inside the configured container.

E.g. `"build": "./BUILD $1 $2"` key in the manifest under `scripts` will cause `lal build dme` to run `./BUILD dme ncp.amd64` in the configured container.
If no positional argument (name) is set, it will assume the repository name and do the canonical build.

At the end of the build, a lockfile will be generated in `OUTPUT`.

#### lal install [name]
Fetches versions corresponding to the manifest from the registry and puts them into `INPUT`.

If the extra positional argument is given, install latest available prebuilt into `INPUT`. If `--save` is given then this also bumps the version in the manifest file.

If positional arguments are given, install all `dependencies`.
If `--dev` is given, then also install all `devDependencies`.

### Uncommon/Advanced/Internal Command Specification
#### lal shell
Enters an interactive shell in the container listed in `.lalrc` mounting the current directory.

Useful for experimental builds with stuff like `bcm` and `opts`.
Assumes you have run `lal install` or equivalent so that `INPUT` is ready for this.

Should run:

```sh
docker run \
  -v $HOME/.gitconfig:/home/lal/.gitconfig \
  -v $PWD:/home/lal/root \
  -w /home/lal/root \
  --net host \
  --cap-add SYS_NICE \
  --user lal \
  -it $LALCONTAINER \
  /bin/bash
```

You may just have your own wrapper for this anyway, but this is the canonical one. You can not use `lal` inside the container (right?).

#### lal link [name]
Verifies that a successful build exists in `$PWD/OUTPUT` then links the `OUTPUT` folder to `~/.lal/cache/links/target/name`.

If a component name is given as the third argument, then look for `~/.lal/cache/links/target/name` and symlink that to `INPUT/NAME`.

#### lal unlink name
Deletes a link in `$PWD/INPUT/name`.

#### lal verify
Verifies that the dependency tree is flat.
Verifies that `manifest.json` is valid json.

#### lal configure
Interactively configures:

- target to inject into `install` and `build` (default: ncp.amd64)
- docker container to use for `build` (default: edonusdevelopers/centos_build)
- git root folder to use for `update` (default: git@sqbu-github.cisco.com:Edonus/)
- registry to use (default: https://artifactory.wherever)
- cache directory to use (default: ~/.lal/cache)

To get defaults use `yes "" | lal configure`.

#### lal deploy
Run `scripts.deploy` in manifest in container.

#### lal test
Run `script.test` in manifest in container.

### Universal Options

- `--log-level=LOG_LEVEL`
- `--help` or `-h`


## Workflow
### Install and Update
Installing pinned versions and building:

```sh
git clone git@sqbu-github.cisco.com:Edonus/monolith
cd monolith
lal install --dev
# for canonical build
lal build
# for experimental
lal shell
docker> ./bcm shared_tests -t
```

Updating dependencies:

```sh
lal install ciscossl 6
lal verify # checks the tree for consistency
git commit manifest.json -m "updated ciscossl to version 6"
git push
```

### Reusing Builds
Using stashed dependencies:

```sh
git clone git@sqbu-github.cisco.com:Edonus/ciscossl
cd ciscossl
# edit
lal build
lal stash asan
cd ../monolith
lal install ciscossl --stash=asan
lal build
```

Using linked dependencies:

```sh
lal update ciscossl
cd ciscossl
# edit
lal build
lal link # keep a symlink to OUTPUT in cache
cd ../monolith
lal link ciscossl # link ciscossl's OUTPUT link to INPUT/ciscossl
lal build
```

The main difference between these two is that the linked dependencies do not need to make an explicit call to update the stash, and another to install it as once the link is established, it will persist until unlinked.

These workflows replace listing multiple components to `./build` and `lal status` replaces the output for the build plan.

### Creating a new version
For small repositories with standard release cycles:

- Bump the version number in the manifest file and create a tag.

For large repositories with constant release cycles:

- No versions are explicitly listed in the manifest
- Dependent repositories (like dme-rpm of dme just lists dme depends on 'latest')

Need some logic so that CI can push to the registry correctly in these cases. Large repositories should push constantly, and small should push on new tag.

Potentially. Still feel that all versions should be in git. But don't want every other commit message to be a tag as that might be quite inefficient/dump/info pulluting.

### Creating a new repository

```sh
mkdir newcomponent
cd newcomponent
yes "" | lal init
git init
git add manifest.json
git ci -m "init newcomponent"
# add git remotes (depends on where we host)
git push -u origin master
lal install gtest --save-dev
lal install libwebsockets --save
# create source and iterate until `lal build` and `lal test` succeeds
git commit -a -m "inital working version"
```

TODO: getting it on CI, and versioning it. `lal version`?

### Historical Documentation
Terms used herin reference [so you want to write a package manager](https://medium.com/@sdboyer/so-you-want-to-write-a-package-manager-4ae9c17d9527#.rlvjqxc4r) (long read).

Original [buildroot notes](https://hg.lal.cisco.com/root/files/tip/NOTES).
